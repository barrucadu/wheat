<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.Wheat</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-Wheat.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Data-Wheat.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">wheat-0.0.0.0: Yet another binary (de-)serialisation library</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Data.Wheat</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Re-exported types</a></li><li><a href="#g:2">ByteStrings</a></li><li><a href="#g:3">Lists</a></li><li><a href="#g:4">Numbers</a></li><li><a href="#g:5">Combinators</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A collection of commonly-used basic codecs and combinators for
 constructing larger codecs.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short">module <a href="Data-Wheat-Types.html">Data.Wheat.Types</a></li><li class="src short"><a href="#v:byteString">byteString</a> :: <a href="Data-Wheat-Types.html#t:Codec">Codec</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:lazyByteString">lazyByteString</a> :: <a href="Data-Wheat-Types.html#t:Codec">Codec</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:constant">constant</a> :: <a href="https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html#t:ByteString">ByteString</a> e</li><li class="src short"><a href="#v:lazyConstant">lazyConstant</a> :: <a href="https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Lazy.html#t:ByteString">ByteString</a> -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Lazy.html#t:ByteString">ByteString</a> e</li><li class="src short"><a href="#v:firstN">firstN</a> :: <a href="https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Data-Wheat-Types.html#t:Codec">Codec</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:lazyFirstN">lazyFirstN</a> :: <a href="https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Data-Wheat-Types.html#t:Codec">Codec</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:elementwise">elementwise</a> :: <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d e -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> [d] [e]</li><li class="src short"><a href="#v:asciiDigits">asciiDigits</a> :: <a href="Data-Wheat-Types.html#t:Codec">Codec</a> <a href="https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:-60-:-62-">(&lt;:&gt;)</a> :: <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d1 e -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d2 e -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> (d1, d2) e</li><li class="src short"><a href="#v:-60--60-:-62--62-">(&lt;&lt;:&gt;&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Monoid.html#t:Monoid">Monoid</a> d =&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d e -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d e -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d e</li><li class="src short"><a href="#v:-60-:-62--62-">(&lt;:&gt;&gt;)</a> :: <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d1 e -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d2 e -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d2 e</li><li class="src short"><a href="#v:-60--60-:-62-">(&lt;&lt;:&gt;)</a> :: <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d1 e -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d2 e -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d1 e</li><li class="src short"><a href="#v:-60--43--43--62-">(&lt;++&gt;)</a> :: <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d1 e1 -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d2 e2 -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> (d1, d2) (e1, e2)</li><li class="src short"><a href="#v:dispatch">dispatch</a> :: <a href="Data-Wheat-Types.html#t:Decoder">Decoder</a> d -&gt; (e -&gt; <a href="https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Builder.html#t:Builder">Builder</a>) -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d e</li><li class="src short"><a href="#v:header">header</a> :: (e -&gt; h) -&gt; <a href="Data-Wheat-Types.html#t:Codec">Codec</a> h -&gt; (h -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d e) -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d e</li><li class="src short"><a href="#v:separate">separate</a> :: (e -&gt; (e1, e2)) -&gt; ((d1, d2) -&gt; d) -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d1 e1 -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d2 e2 -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d e</li></ul></div><div id="interface"><h1 id="g:1">Re-exported types</h1><div class="top"><p class="src">module <a href="Data-Wheat-Types.html">Data.Wheat.Types</a></p></div><h1 id="g:2">ByteStrings</h1><div class="top"><p class="src"><a name="v:byteString" class="def">byteString</a> :: <a href="Data-Wheat-Types.html#t:Codec">Codec</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html#t:ByteString">ByteString</a> <a href="src/Data-Wheat.html#byteString" class="link">Source</a></p><div class="doc"><p>Encode a ByteString (the identity codec)</p></div></div><div class="top"><p class="src"><a name="v:lazyByteString" class="def">lazyByteString</a> :: <a href="Data-Wheat-Types.html#t:Codec">Codec</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Lazy.html#t:ByteString">ByteString</a> <a href="src/Data-Wheat.html#lazyByteString" class="link">Source</a></p><div class="doc"><p>Encode a lazy ByteString (the identity codec)</p></div></div><div class="top"><p class="src"><a name="v:constant" class="def">constant</a> :: <a href="https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html#t:ByteString">ByteString</a> e <a href="src/Data-Wheat.html#constant" class="link">Source</a></p><div class="doc"><p>Encode a constant ByteString.</p><p>Decoding will fail if the supplied ByteString is not a prefix of
 the actual one. Encoding will ignore its argument.</p></div></div><div class="top"><p class="src"><a name="v:lazyConstant" class="def">lazyConstant</a> :: <a href="https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Lazy.html#t:ByteString">ByteString</a> -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Lazy.html#t:ByteString">ByteString</a> e <a href="src/Data-Wheat.html#lazyConstant" class="link">Source</a></p><div class="doc"><p>Encode a constant lazy ByteString.</p><p>Decoding will fail if the actual ByteString differs from the
 supplied one. Encoding will ignore its argument.</p></div></div><div class="top"><p class="src"><a name="v:firstN" class="def">firstN</a> :: <a href="https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Data-Wheat-Types.html#t:Codec">Codec</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html#t:ByteString">ByteString</a> <a href="src/Data-Wheat.html#firstN" class="link">Source</a></p><div class="doc"><p>Encode the first N bytes of a ByteString.</p><p>Decoding will fail if the actual ByteString is not at least as long
 as the given length.</p></div></div><div class="top"><p class="src"><a name="v:lazyFirstN" class="def">lazyFirstN</a> :: <a href="https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Data-Wheat-Types.html#t:Codec">Codec</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Lazy.html#t:ByteString">ByteString</a> <a href="src/Data-Wheat.html#lazyFirstN" class="link">Source</a></p><div class="doc"><p>Encode the first N bytes of a lazy ByteString.</p><p>Decoding will fail if the actual ByteString is not at least as long
 as the given length.</p></div></div><h1 id="g:3">Lists</h1><div class="top"><p class="src"><a name="v:elementwise" class="def">elementwise</a> :: <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d e -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> [d] [e] <a href="src/Data-Wheat.html#elementwise" class="link">Source</a></p><div class="doc"><p>Lift a codec over a type to over a list of that type.</p><p>Encoded elements are concatenated. Decoding never fails, as an
 empty list is acceptable.</p></div></div><h1 id="g:4">Numbers</h1><div class="top"><p class="src"><a name="v:asciiDigits" class="def">asciiDigits</a> :: <a href="Data-Wheat-Types.html#t:Codec">Codec</a> <a href="https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Int.html#t:Int">Int</a> <a href="src/Data-Wheat.html#asciiDigits" class="link">Source</a></p><div class="doc"><p>Encode an Int as ASCII digits.</p><p>Decoding will consume as many bytes from the start of the input as
 represent ASCII digits, failing only if no bytes do.</p></div></div><h1 id="g:5">Combinators</h1><div class="top"><p class="src"><a name="v:-60-:-62-" class="def">(&lt;:&gt;)</a> :: <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d1 e -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d2 e -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> (d1, d2) e <a href="src/Data-Wheat.html#%3C%3A%3E" class="link">Source</a></p><div class="doc"><p>Sequential composition of codecs.</p><p>When encoding, the input value is encoded with both codecs and the
 results are concatenated. When decoding, the remaining bytestring
 from the first codec is used as input to the second.</p></div></div><div class="top"><p class="src"><a name="v:-60--60-:-62--62-" class="def">(&lt;&lt;:&gt;&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Monoid.html#t:Monoid">Monoid</a> d =&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d e -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d e -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d e <a href="src/Data-Wheat.html#%3C%3C%3A%3E%3E" class="link">Source</a></p><div class="doc"><p>Sequential composition of codecs, combining the results of
 decoding monoidally.</p></div></div><div class="top"><p class="src"><a name="v:-60-:-62--62-" class="def">(&lt;:&gt;&gt;)</a> :: <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d1 e -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d2 e -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d2 e <a href="src/Data-Wheat.html#%3C%3A%3E%3E" class="link">Source</a></p><div class="doc"><p>Right-biased sequential composition of codecs.</p><p>Encoding behaviour is the same as <code><a href="Data-Wheat.html#v:-60-:-62-">&lt;:&gt;</a></code>, decoding throws away the
 result of the first codec.</p></div></div><div class="top"><p class="src"><a name="v:-60--60-:-62-" class="def">(&lt;&lt;:&gt;)</a> :: <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d1 e -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d2 e -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d1 e <a href="src/Data-Wheat.html#%3C%3C%3A%3E" class="link">Source</a></p><div class="doc"><p>Left-biased sequential composition of codecs.</p><p>Encoding behaviour is the same as <code><a href="Data-Wheat.html#v:-60-:-62-">&lt;:&gt;</a></code>, decoding throws away the
 result of the second codec.</p></div></div><div class="top"><p class="src"><a name="v:-60--43--43--62-" class="def">(&lt;++&gt;)</a> :: <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d1 e1 -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d2 e2 -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> (d1, d2) (e1, e2) <a href="src/Data-Wheat.html#%3C%2B%2B%3E" class="link">Source</a></p><div class="doc"><p>Combine two codecs into a codec for tuples of those types, where
 the encoded forms of each element are concatenated.</p></div></div><div class="top"><p class="src"><a name="v:dispatch" class="def">dispatch</a> :: <a href="Data-Wheat-Types.html#t:Decoder">Decoder</a> d -&gt; (e -&gt; <a href="https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Builder.html#t:Builder">Builder</a>) -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d e <a href="src/Data-Wheat.html#dispatch" class="link">Source</a></p><div class="doc"><p>Choose an encoder based on the actual value being encoded, with a
 decoder.</p><p>Be careful that this codec actually does express a reversible
 encoding when you have <code>d == e</code>!</p></div></div><div class="top"><p class="src"><a name="v:header" class="def">header</a> :: (e -&gt; h) -&gt; <a href="Data-Wheat-Types.html#t:Codec">Codec</a> h -&gt; (h -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d e) -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d e <a href="src/Data-Wheat.html#header" class="link">Source</a></p><div class="doc"><p>Encode a value as a combination of header and encoded value. The
 codec used for encoding/decoding the value itself receives the
 (encoded/decoded) header as a parameter.</p></div></div><div class="top"><p class="src"><a name="v:separate" class="def">separate</a> :: (e -&gt; (e1, e2)) -&gt; ((d1, d2) -&gt; d) -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d1 e1 -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d2 e2 -&gt; <a href="Data-Wheat-Types.html#t:Codec-39-">Codec'</a> d e <a href="src/Data-Wheat.html#separate" class="link">Source</a></p><div class="doc"><p>Apply a divide-and-conquer approach: given a function to split up
 the encoding into two smaller components, and a function to combine
 the smaller components after decoding, construct a codec for the
 more complex type.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.0</p></div></body></html>